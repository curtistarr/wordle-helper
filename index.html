<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Wordle Helper</title>
  <style>
    body { font-family: system-ui, -apple-system, Arial; max-width: 820px; margin: 24px auto; padding: 0 16px; color:#111 }
    .row { display:flex; gap:8px; margin:12px 0; flex-wrap:wrap }
    .tile {
      width:56px; height:56px; display:flex; align-items:center; justify-content:center;
      border-radius:6px; font-weight:700; font-size:20px; cursor:pointer; user-select:none;
      border:2px solid #ccc; background:#f4f4f4;
    }
    .tile.gray { background:#818384; color:white; border-color:#818384 }
    .tile.yellow { background:#b59f3b; color:white; border-color:#b59f3b }
    .tile.green { background:#538d4e; color:white; border-color:#538d4e }
    input[type="text"] { font-size:18px; padding:8px; width:260px }
    button { padding:8px 12px; font-size:15px; cursor:pointer }
    #suggestions { margin-top:12px }
    .suggestion { padding:6px 8px; border-radius:6px; background:#eee; margin:4px; display:inline-block; cursor:pointer }
    .meta { margin-top:8px; color:#555 }
    a { color:#06c }
    pre { background:#f7f7f7; padding:8px; border-radius:6px; overflow:auto }
  </style>
</head>
<body>
  <h2>Wordle Helper</h2>
  <div>
    - Type a 5-letter guess or click a suggested word. Click each letter tile to cycle feedback: gray → yellow → green. Then press "Submit feedback".
  </div>

  <div class="row" style="margin-top:18px; align-items:center">
    <input id="guessInput" placeholder="enter a 5-letter guess" maxlength="5" />
    <button id="useGuess">Use / Add Tiles</button>
    <button id="submitFeedback">Submit feedback</button>
    <button id="reset">Reset</button>
  </div>

  <div id="tiles" class="row" aria-label="feedback tiles"></div>

  <div class="meta" id="meta"></div>

  <div id="suggestions">
    <h3>Top suggestions</h3>
    <div id="suggestList"></div>
  </div>

  <details style="margin-top:12px">
    <summary>Advanced: full word list source & how it works</summary>
    <div style="margin-top:8px">
      The helper fetches a Wordle word list (default URL). If that fails, it uses a built-in small list. It filters candidates by simulating Wordle feedback for each submitted guess (so duplicate letters are handled correctly), then ranks remaining words by letter-frequency heuristic.
      <div style="margin-top:8px">
        You can change the word list URL inside the script if you prefer a different source.
      </div>
    </div>
  </details>

  <script>
  // Configuration: change this URL to another raw word list if you want.
  const WORD_LIST_URL = 'https://raw.githubusercontent.com/tabatkins/wordle-list/main/words';

  // Small fallback word list (common 5-letter words). Replace or extend if desired.
  const FALLBACK_WORDS = [
    'crane','slate','slice','adieu','arise','shine','crate','trace','slant','panel',
    'roast','point','grace','blush','shine','bring','gripe','stole','ought','alone',
    'about','could','would','plant','mixed','shard','phone','drive','charm','quilt',
    'speak','touch','quick','brown','ghost','flame','month','candy','dance','eager',
    'fifty','gauge','hinge','index','jolly','koala','limit','moral','noble','olive'
  ];

  let words = [];        // candidate words
  let allWords = [];     // all allowed guesses (if available)
  const guesses = [];    // {word, states[]} states: 0 gray,1 yellow,2 green

  // UI elements
  const guessInput = document.getElementById('guessInput');
  const useGuessBtn = document.getElementById('useGuess');
  const submitBtn = document.getElementById('submitFeedback');
  const resetBtn = document.getElementById('reset');
  const tilesDiv = document.getElementById('tiles');
  const suggestList = document.getElementById('suggestList');
  const meta = document.getElementById('meta');

  function createTilesFromWord(word) {
    tilesDiv.innerHTML = '';
    for (let i=0;i<5;i++){
      const ch = (word[i] || '').toLowerCase();
      const tile = document.createElement('div');
      tile.className = 'tile';
      tile.textContent = ch || '-';
      tile.dataset.pos = i;
      tile.dataset.state = '0'; // 0 gray,1 yellow,2 green
      tile.onclick = () => {
        const s = (parseInt(tile.dataset.state) + 1) % 3;
        tile.dataset.state = ''+s;
        tile.classList.remove('gray','yellow','green');
        if (s===0) tile.classList.add('gray');
        if (s===1) tile.classList.add('yellow');
        if (s===2) tile.classList.add('green');
      };
      tile.classList.add('gray');
      tilesDiv.appendChild(tile);
    }
  }

  function getTilesFeedback() {
    const tiles = Array.from(tilesDiv.children);
    if (tiles.length !== 5) return null;
    const word = tiles.map(t=>t.textContent || '-').join('').toLowerCase();
    const states = tiles.map(t=>parseInt(t.dataset.state));
    return { word, states };
  }

  function simulateFeedback(guess, target) {
    // return array of 5 states for how Wordle would mark `guess` against `target`
    // 2 green,1 yellow,0 gray
    guess = guess.toLowerCase();
    target = target.toLowerCase();
    const states = [0,0,0,0,0];
    const targetArr = target.split('');
    // greens
    for (let i=0;i<5;i++){
      if (guess[i] === targetArr[i]) {
        states[i] = 2;
        targetArr[i] = null; // consume
      }
    }
    // yellows
    for (let i=0;i<5;i++){
      if (states[i]===0) {
        const idx = targetArr.indexOf(guess[i]);
        if (idx !== -1) {
          states[i] = 1;
          targetArr[idx] = null; // consume
        }
      }
    }
    return states;
  }

  function matchesAllGuesses(candidate) {
    for (const g of guesses) {
      const sim = simulateFeedback(g.word, candidate);
      for (let i=0;i<5;i++){
        if (sim[i] !== g.states[i]) return false;
      }
    }
    return true;
  }

  function filterCandidates() {
    words = allWords.filter(matchesAllGuesses);
  }

  function rankCandidates(limit=10) {
    // compute positional and overall frequencies from remaining candidates
    const posFreq = Array.from({length:5}, ()=> ({}));
    const freq = {};
    for (const w of words) {
      for (let i=0;i<5;i++){
        const ch = w[i];
        posFreq[i][ch] = (posFreq[i][ch] || 0) + 1;
        freq[ch] = (freq[ch] || 0) + 1;
      }
    }
    // score each candidate: sum of positional freq + overall freq for unique letters
    const scored = words.map(w=>{
      let score = 0;
      const seen = new Set();
      for (let i=0;i<5;i++){
        const ch = w[i];
        score += (posFreq[i][ch] || 0) * 2; // positional weight
        if (!seen.has(ch)) {
          score += (freq[ch] || 0);
          seen.add(ch);
        }
      }
      return {w, score};
    });
    scored.sort((a,b)=>b.score - a.score);
    return scored.slice(0, limit).map(s=>s.w);
  }

  function updateUI() {
    filterCandidates();
    const top = rankCandidates(10);
    suggestList.innerHTML = '';
    for (const s of top) {
      const el = document.createElement('span');
      el.className = 'suggestion';
      el.textContent = s;
      el.onclick = ()=> {
        guessInput.value = s;
        createTilesFromWord(s);
      };
      suggestList.appendChild(el);
    }
    meta.textContent = `${words.length} candidates remaining. ${guesses.length} guesses recorded.`;
  }

  // handlers
  useGuessBtn.onclick = () => {
    const val = (guessInput.value || '').trim().toLowerCase();
    if (val.length !== 5) {
      alert('Enter a 5-letter word.');
      return;
    }
    createTilesFromWord(val);
  };

  submitBtn.onclick = () => {
    const fb = getTilesFeedback();
    if (!fb) { alert('Create tiles first by typing a guess and clicking "Use / Add Tiles".'); return; }
    if (fb.word.includes('-')) { alert('Tiles contain empty letters.'); return; }
    guesses.push({word: fb.word, states: fb.states});
    guessInput.value = '';
    createTilesFromWord(''); // clear tiles
    updateUI();
  };

  resetBtn.onclick = () => {
    if (!confirm('Reset all guesses and candidates?')) return;
    guesses.length = 0;
    loadWords(true);
  };

  // load word list (attempt remote, otherwise fallback)
  async function loadWords(forceFallback=false) {
    try {
      if (forceFallback) throw new Error('forced');
      const r = await fetch(WORD_LIST_URL);
      if (!r.ok) throw new Error('fetch failed');
      const txt = await r.text();
      // The file at the URL is expected to be one 5-letter word per line
      const list = txt.split(/\r?\n/).map(s=>s.trim().toLowerCase()).filter(s=>s.length===5);
      allWords = list.length ? list : FALLBACK_WORDS.slice();
    } catch (err) {
      console.warn('Using fallback word list:', err);
      allWords = FALLBACK_WORDS.slice();
    }
    // initialize
    words = allWords.slice();
    updateUI();
  }

  // load on start
  createTilesFromWord('');
  loadWords();

  // allow pressing Enter in input to create tiles
  guessInput.addEventListener('keydown', (e)=>{
    if (e.key === 'Enter') {
      useGuessBtn.click();
    }
  });
  </script>
</body>
</html>
